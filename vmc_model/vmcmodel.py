# -*- coding: utf-8 -*-
"""VMCModel

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1prfE9LSNVkrUA-WW9nzIWwakJyd7OV7u
"""

import numpy as np
from scipy.misc import derivative
import scipy.linalg

H = np.array([[0., 1.], [1., 0.]])


def wf(x0):
  return x0/np.linalg.norm(x0)

eps = 1.e-4
def deriv_wf(x0):
  return ((wf(x0+np.array([eps,0.]))-wf(x0))/eps, (wf(x0+np.array([0.,eps]))-wf(x0))/eps)

c = np.array([0.1,0.5])
c0 = wf(c)
print(c0)
g= np.zeros([2, 2])
g0, g1=deriv_wf(c0)
g[:,0]=g0
g[:,1]=g1

print (np.dot(g0, c0))
print (np.dot(g1, c0))

def make_hess(L):
  hess= np.zeros([2*L,2*L])
  for atom1 in range(L):
    for atom2 in range(L):
      if (atom1 != atom2):
        for i in range(2):
          for j in range(2):
            hess[2*atom1 + i, 2*atom2 + j] = (g[:,i].T @ H @ c0) * (c0.T @ H @ g[:,j])

  for atom1 in range(L):
    for i in range(2):
      for j in range(2):
        hess[2*atom1 +i, 2*atom1+j] = (g[:,i].T @ H @ g[:,j])
  return hess

def make_ovlp(L):
  ovlp = np.zeros([2*L,2*L])
  for atom1 in range(L):
    for atom2 in range(L):
      for i in range(2):
        for j in range(2):
          ovlp[2*atom1 + i, 2*atom2 + j] = (g[:,i].T @ c0) * (c0.T @ g[:,j])
  for atom1 in range(L):
    for i in range(2):
      for j in range(2):
        ovlp[2*atom1 + i, 2*atom1+j] = g[:,i].T @ g[:,j]
  return ovlp

for L in range(1,50):
  hess = make_hess(L)
  ovlp = make_ovlp(L)
  ovlp += 1.e-5 * np.eye(ovlp.shape[0])
  #print(np.linalg.eigvals(ovlp))
  eigs = scipy.linalg.eigvalsh(hess, ovlp)
  # hess = np.linalg.inv(ovlp) @ hess
  # trace = np.trace(hess)
  sumeigs = np.sum(np.abs(eigs))
  maxeig = np.max(np.abs(eigs))
  print(L,sumeigs/maxeig)
  #  print(np.sum(eigs))/np.max(np.abs(eigs))
  #print(np.max(np.abs(eigs)))

